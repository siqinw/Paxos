Key-Value Store with Java RMI

Features
- Remote Procedure Call (RPC) support using Java RMI.
- Multi-threaded server that can handle multiple client requests concurrently.
- Pre-populated key-value store to test basic operations.
- Server amd Client logging for debugging and tracking operations.
- Graceful shutdown handling for both client and server.

Technologies Used
- Java RMI (Remote Method Invocation)
- ConcurrentHashMap for thread-safe storage
- ExecutorService for multi-threaded request handling

Setup and Execution
1. Build Java code
In the terminal,
javac src/RPC/*.java;

2. Start the Server
In the terminal, start the server:
cd src/;
java RPC.KeyValueStoreServer;

Expected output:
[LOG] <timestamp> - Key-Value Store RMI Server is running and ready to accept client connections...


3. Start the Client
Open a new terminal window and start the client:
cd src/;
java RPC.KeyValueStoreClient 127.0.0.1

Expected output:
[LOG] <timestamp> - Connected to Key-Value Store RMI Server.
[LOG] <timestamp> - Pre-populating Key-Value Store with initial data...

4. Testing the Key-Value Store
You can manually enter commands to test the server:
PUT name Alice
GET name
DELETE name

Expected responses:
Response: PUT OK: name
Response: VALUE: Alice
Response: DELETE OK: name

4. Stopping the Server & Clients
- To stop the server, press `CTRL+C` in the terminal.
- To stop the client, press `CTRL+C` or type in "exit" in the terminal.


Executive Summary

Assignment Overview
This project extends the scope of previous project by introducing RPC and multi-threading server support.
Socket programming is replaced with RPC, making the client-server architecture more scalable, while Java Remote Method Invocation (RMI) enables efficient method invocation on remote systems.
The project also emphasizes on multi-threading by ensuring that the server could handle multiple client requests at the same time. The client is responsible for sending requests (namely, PUT, GET, and DELETE) to store and retrieve data remotely.
Additionally, the programs include automated pre-population of the key-value pairs and logging mechanisms to track server-client interactions.

Technical Impression
A crucial aspect of the project was implementing multi-threading support on the server to allow concurrent client requests.
By utilizing thread pool and ConcurrentHashMap, the server could gracefully support multiple requests at the same time.
To test the concurrent functionality, several clients were run simultaneously, and it was confirmed that requests were processed correctly without unexpected failures.
Through the assignment, I gained hands-on experience on Java concurrent programming.

Working on this project also provided me significant insights into Java RMI and its advantages over traditional socket-based communication.
Setting up the RMI registry, binding remote objects, and ensuring reliable client-server communication requires understanding of serialization, stub generation, and remote interface implementation.
One of the main challenges that I encountered was handling remote exceptions, particularly dealing with network failures and server unavailability.
Implementing graceful error handling helped improve the systemâ€™s robustness and reliability.

One potential improvement that I could think of is to include persistent storage on server, instead of relying on volatile memory, so that it could ensure data durability across server reboots.
Additionally, we could enhance system security by incorporating authentication and encryption, as it is more applicable to real-world scenarios.
Overall, this project reinforced key concepts in distributed systems, offering a solid foundation for designing scalable and resilient distributed systems.

